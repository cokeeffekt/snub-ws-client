{"version":3,"file":"snub-ws-client.min.js","sources":["../src/worker.js","../src/index.js"],"sourcesContent":["const worker = (function (root) {\n  // Store connected ports in case this is a SharedWorker\n  const ports = [];\n  let currentSocket = null;\n\n  let postToMain = () => {};\n  let config = {};\n  // Check if we are in a Worker context or the main thread\n  const isWorkerContext =\n    typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope;\n  const isSharedWorkerContext =\n    typeof SharedWorkerGlobalScope !== 'undefined' &&\n    self instanceof SharedWorkerGlobalScope;\n\n  if (isSharedWorkerContext) {\n    // Running in a SharedWorker context\n    self.onconnect = function (e) {\n      const port = e.ports[0];\n      ports.push(port);\n\n      port.onmessage = handleIncomingMessage;\n      port.start();\n      postMessage(['_internal:connected']);\n    };\n  } else if (isWorkerContext) {\n    // Running in a Worker context\n    self.onmessage = handleIncomingMessage;\n    postMessage(['_internal:connected']);\n  }\n\n  return {\n    postToMain: (fn) => (postToMain = fn), // set the postMessage function for the main thread\n    handleIncomingMessage,\n    ready() {\n      postMessage(['_internal:connected']);\n    },\n  };\n\n  // Utility function to send a message in worker or main thread\n  function postMessage(msg) {\n    msg = stringifyJson(msg);\n    if (isSharedWorkerContext) {\n      // Post message to all connected ports\n      ports.forEach((port) => port.postMessage(msg));\n    } else if (isWorkerContext) {\n      // Post message to the main script\n      self.postMessage(msg);\n    } else {\n      // Call the main thread handler\n      postToMain({ data: msg });\n    }\n  }\n\n  // Common functionality that runs in both the workers and main thread\n  function handleIncomingMessage(msg) {\n    const [event, payload] = parseJson(msg.data);\n    if (event === '_config') {\n      config = { ...config, ...payload };\n      config.httpUrl = config.url.replace(/^ws/, 'http')\n    }\n    if (event === '_connect') {\n      connectSocket(payload);\n    }\n    if (event === '_close') {\n      if (currentSocket) {\n        currentSocket.close(...payload);\n      }\n    }\n    if (event === '_send') {\n      if (currentSocket) {\n        currentSocket.send(stringifyJson(payload));\n      }\n    }\n  }\n\n  async function connectSocket(auth) {\n    if (currentSocket) {\n      // close socket and wait for the socket to close asychronously\n      currentSocket.close();\n      await new Promise((resolve) => {\n        currentSocket.onclose = () => {\n          resolve();\n        };\n      });\n    }\n\n    currentSocket = new WebSocket(config.url);\n\n    currentSocket.onopen = () => {\n      currentSocket.send(stringifyJson(['_auth', auth]));\n    };\n    currentSocket.onmessage = (event) => {\n      const [key, payload] = parseJson(event.data);\n      if (key === '_acceptAuth') {\n        return postMessage(['_internal:socket-connect', payload]);\n      }\n      if (key === '_offload') {\n        return (async () => {\n          const result = await fetch(config.httpUrl + `?offload=${payload}`);\n          if (!result.ok) {\n            return console.error('offload failed');\n          }\n          let data = await result.text();\n          data = parseJson(data);\n          postMessage([...data]);\n        })();\n      }\n      return postMessage([key, payload]);\n    };\n    currentSocket.onclose = (event) => {\n      console.log(event);\n      // https://github.com/Luka967/websocket-close-codes\n      postMessage(['_internal:socket-disconnected', {\n        code: event.code,\n        reason: event.reason,\n      }]);\n      currentSocket = null;\n    };\n    currentSocket.onerror = (error) => {\n      console.error('Snub-Ws-Socket => Socket error:', error);\n    };\n  }\n})(typeof self !== 'undefined' ? self : this);\n\nexport default {\n  postMessage: worker.handleIncomingMessage,\n  postToMain: worker.postToMain,\n  ready: worker.ready,\n};\n\n\nfunction stringifyJson(obj) {\n  return JSON.stringify(obj, (key, value) => {\n    if (value instanceof Map) {\n      return {\n        dataType: 'Map',\n        value: Array.from(value.entries()), // Convert Map to array of key-value pairs\n      };\n    } else if (value instanceof Set) {\n      return {\n        dataType: 'Set',\n        value: Array.from(value), // Convert Set to array\n      };\n    }\n    return value;\n  });\n}\n\nfunction parseJson(json) {\n  return JSON.parse(json, (key, value) => {\n    if (value && value.dataType === 'Map') {\n      return new Map(value.value); // Convert array of key-value pairs back to Map\n    } else if (value && value.dataType === 'Set') {\n      return new Set(value.value); // Convert array back to Set\n    }\n    return value;\n  });\n}","import workerScriptUrl from './worker.js'; // Will be a data URL if inlined\n\nconst DEFAULT_CONFIG = {\n  workerType: 'SHARED_WORKER', // 'SHARED_WORKER', 'WEB_WORKER', 'MAIN_THREAD'\n  workerName: 'Snub-Ws-Client-Worker',\n  url: 'ws://localhost:8080',\n  replyTimeout: 10000,\n};\nexport default class SnubWsClient {\n  #workerType = null;\n  #worker = null;\n  #config = DEFAULT_CONFIG;\n  #state = 'init';\n  #pendingConnect = null;\n  #waitingReplies = new Map();\n\n  // Event handlers\n  #onmessage = () => {};\n  #onopen = () => {};\n  #onclose = () => {};\n\n  constructor(config) {\n    this.#config = { ...DEFAULT_CONFIG, ...config };\n    // start the worker\n    this.#worker = this.#startWorker();\n    JSONifyWorker(this.#worker); // JSONify the worker\n    this.#worker.onmessage = (event) => {\n      const [key, value] = parseJson(event.data);\n      if (key === '_internal:connected') {\n        this.#worker.postMessage([\n          '_config',\n          {\n            url: this.#config.url,\n          },\n        ]);\n        this.#state = 'READY';\n        if (this.#pendingConnect) this.connect(this.#pendingConnect);\n        this.#pendingConnect = null;\n      }\n      if (key === '_internal:socket-disconnected') {\n        this.#onclose(value);\n      }\n      if (key === '_internal:socket-connect') {\n        this.#onopen(value);\n      }\n      const [prefix, uid, type] = key.split(':');\n      if (prefix === '_internal') return;\n\n      if (prefix === '_r') {\n        const findReply = this.#waitingReplies.get(\n          prefix + ':' + uid\n        );\n        if (!findReply) {\n          console.warn('Reply not found:', key, value); // dont know what this is about, keeping an eye on it.\n          return;\n        };\n        const [resolve, reject, timeout] = findReply;\n        clearTimeout(timeout);\n        this.#waitingReplies.delete(prefix + ':' + uid);\n        if (type === 'error' && reject) return reject(value);\n        if (resolve) return resolve(value);\n        return;\n      }\n      this.#onmessage(key, value);\n    };\n  }\n\n  send(event, payload) {\n    this.#worker.postMessage(['_send', [event, payload]]);\n  }\n  fetch(event, payload) {\n    return new Promise((resolve, reject) => {\n      const uid = '_r:' + generateUID();\n      const timeout = setTimeout(() => {\n        reject(new Error('Timeout'));\n        this.#waitingReplies.delete(uid);\n      }, this.#config.replyTimeout);\n      this.#waitingReplies.set(uid, [resolve, reject, timeout]);\n      this.#worker.postMessage(['_send', [event, payload, uid]]);\n    });\n  }\n\n  connect(auth) {\n    if (this.#state === 'READY') {\n      this.#worker.postMessage(['_connect', auth]);\n    } else {\n      this.#pendingConnect = auth;\n    }\n  }\n\n  close(code, reason) {\n    this.#worker.postMessage(['_close', [code, reason]]);\n  }\n\n  onopen(fn) {\n    this.#onopen = fn;\n  }\n  onmessage(fn) {\n    this.#onmessage = fn;\n  }\n\n  onclose(fn) {\n    this.#onclose = fn;\n  }\n\n  // Private functions\n  #startWorker() {\n    // Check if SharedWorker is supported\n    if (\n      typeof SharedWorker !== 'undefined' &&\n      !['WEB_WORKER', 'MAIN_THREAD'].includes(this.#config.workerType)\n    ) {\n      try {\n        const sharedWorker = new SharedWorkerWrapper(workerScriptUrl, {\n          type: 'module',\n          name: this.#config.workerName,\n        });\n        this.#workerType = 'sharedWorker';\n        return sharedWorker;\n      } catch (e) {}\n    }\n\n    // Check if Web Worker is supported\n    if (\n      typeof Worker !== 'undefined' &&\n      !['MAIN_THREAD'].includes(this.#config.workerType)\n    ) {\n      try {\n        const webWorker = new Worker(workerScriptUrl, {\n          type: 'module',\n          name: this.#config.workerName,\n        });\n        this.#workerType = 'webWorker';\n        return webWorker;\n      } catch (e) {}\n    }\n\n    // Fallback to running in the main thread\n    this.#workerType = 'mainThread';\n\n    const mainThreadWorker = {\n      postMessage: function (message) {},\n      onmessage: function (event) {},\n    };\n    // Load the worker script in the main thread\n    import(workerScriptUrl)\n      .then((module) => {\n        mainThreadWorker.postMessage = (msg) => {\n          module.default.postMessage({ data: stringifyJson(msg) });\n        };\n        mainThreadWorker.postToMain = module.default.postToMain((msg) => {\n          mainThreadWorker.onmessage(msg);\n        });\n        module.default.ready();\n      })\n      .catch((error) => {\n        console.error('Failed to load worker script:', error);\n      });\n\n    return mainThreadWorker;\n  }\n}\n\nclass SharedWorkerWrapper {\n  constructor(url, options) {\n    this.worker = new SharedWorker(url, options); // Load SharedWorker\n    this.port = this.worker.port;\n\n    // Start the port for communication\n    this.port.start();\n\n    // Proxy the onmessage event\n    this.port.onmessage = (event) => {\n      if (typeof this.onmessage === 'function') {\n        this.onmessage(event); // Call the main thread's onmessage handler\n      }\n    };\n\n    // Optional: Proxy onerror handling\n    this.port.onerror = (error) => {\n      if (typeof this.onerror === 'function') {\n        this.onerror(error); // Call the main thread's onerror handler\n      }\n    };\n  }\n\n  postMessage(message) {\n    this.port.postMessage(message);\n  }\n\n  terminate() {\n    this.port.close(); // Close the port to stop communication\n  }\n}\n\nfunction JSONifyWorker(worker) {\n  worker._postMessage = worker.postMessage;\n  worker.postMessage = function (message) {\n    worker._postMessage(stringifyJson(message));\n  };\n}\n\nfunction generateUID() {\n  let firstPart = (Math.random() * 46656) | 0;\n  let secondPart = (Math.random() * 46656) | 0;\n  firstPart = ('000' + firstPart.toString(36)).slice(-3);\n  secondPart = ('000' + secondPart.toString(36)).slice(-3);\n  return firstPart + secondPart;\n}\n\nfunction stringifyJson(obj) {\n  return JSON.stringify(obj, (key, value) => {\n    if (value instanceof Map) {\n      return {\n        dataType: 'Map',\n        value: Array.from(value.entries()), // Convert Map to array of key-value pairs\n      };\n    } else if (value instanceof Set) {\n      return {\n        dataType: 'Set',\n        value: Array.from(value), // Convert Set to array\n      };\n    }\n    return value;\n  });\n}\n\nfunction parseJson(json) {\n  return JSON.parse(json, (key, value) => {\n    if (value && value.dataType === 'Map') {\n      return new Map(value.value); // Convert array of key-value pairs back to Map\n    } else if (value && value.dataType === 'Set') {\n      return new Set(value.value); // Convert array back to Set\n    }\n    return value;\n  });\n}\n"],"names":["blob","Blob","type","URL","createObjectURL","DEFAULT_CONFIG","workerType","workerName","url","replyTimeout","SharedWorkerWrapper","constructor","options","this","worker","SharedWorker","port","start","onmessage","event","onerror","error","postMessage","message","terminate","close","stringifyJson","obj","JSON","stringify","key","value","Map","dataType","Array","from","entries","Set","config","state","pendingConnect","waitingReplies","onopen","onclose","startWorker","_postMessage","json","data","parse","connect","prefix","uid","split","findReply","get","console","warn","resolve","reject","timeout","clearTimeout","delete","send","payload","fetch","Promise","firstPart","Math","random","secondPart","toString","slice","generateUID","setTimeout","Error","set","auth","code","reason","fn","includes","sharedWorker","workerScriptUrl","name","e","Worker","webWorker","mainThreadWorker","import","then","module","msg","default","postToMain","ready","catch"],"mappings":"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"}